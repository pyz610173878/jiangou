

# 大 O 复杂度表示法

算法的执行效率，粗略地讲，就是算法代码执行的**时间**。

但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？这里有段非常简单的代码，求 1,2,3...n 的累加和。现在，我就带你一块来估算一下这段代码的执行时间。

## e 求1 2 3 累加

```C

 int cal(int n) {
   int sum = 0;
   int i = 1;
   for (; i <= n; ++i) {
     sum = sum + i;
   }
   return sum;
 }
```

## c q 不太懂

从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？

第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time。可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。





```C

 int cal(int n) {
   int sum = 0;
   int i = 1;
   int j = 1;
   for (; i <= n; ++i) {
     j = 1;
     for (; j <= n; ++j) {
       sum = sum +  i * j;
     }
   }
 }
```





所有代码的执行时间 T(n) 与每行代码的执行次数 f(n) 成正比。

f(n) 为函数的执行次数





## d 规律归纳 

![image-20221109161040826](%E5%A4%A7%20O%20%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8%E7%A4%BA%E6%B3%95.assets/image-20221109161040826-16679814416301.png)

## e 详细解释

其中，T(n) 我们已经讲过了，它表示代码执行的总时间。

n 表示数据规模的大小；(有多少代码)

f(n) 表示每行代码执行的次数总和。

因为这是一个公式，所以用 f(n) 来表示。

公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比